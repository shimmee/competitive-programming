# ARC119
# URL:
# Date: 2021/05/16

# ---------- Ideas ----------
# 1と0の出現個数が違う場合は無理で-1出力
# 0と1が隣り合ってたら，0を1の方向に好きなところまで1回で移動できる
# それぞれのSに入ってる1が，自分がいるべきポジションまでに何個0の塊が入ってるか

# 現在，Tの何が何個の塊でほしいのか



# ------------------- Solution --------------------
#

# ------------------- Answer --------------------
#code:python
from collections import deque, Counter
n = int(input())
S = input()
T = input()

search = True
ans = 0
now = -1
cnt_t = 0
for i in range(n):
    if search: # Tの中に連続して存在するやつを探す
        if now == -1:
            now = T[i]
            cnt_t = 1
        else:
            if now != T[i]: # ここでサーチを止める
                search = False

            else:
                cnt_t += 1
    else: # この時点で，Tのi-cnt_t番目からi番目までに，cnt_tがnow個が入ってる
        # Sの中で，iからスタートして目的のnowがcnt_t個出現するまで進める
        # 同時に，nowじゃないやつが，塊で何個あるのか数える: cnt_s_not
        cnt_s_now = 0
        cnt_s_not = 0
        l = []
        j = i-cnt_t-1
        while True:
            if S[j] == now:
                cnt_s_now += 1
            else:
                cnt_s_not += 1
            if cnt_s_now == cnt_t:
                break
            else:
                j += 1

        # この時点で，Sのj番目までは

        search = True

# 誤読してました
# 00001は10000にできません
# 11110を01111にするか，その逆だけです。つまり，0を移動させられるだけです。




# ------------------ Sample Input -------------------
6
000111
111000


119
10101111011101001011111000111111101011110011010111111111111111010111111111111110111111110111110111101111111111110111011
11111111111111111111111111011111101011111011110111110010100101001110111011110111111111110010011111101111111101110111011


# ----------------- Length of time ------------------
#

# -------------- Editorial / my impression -------------
#

# ----------------- Category ------------------
#AtCoder
#AC_with_editorial #解説AC
#wanna_review #hard復習 #復習したい
