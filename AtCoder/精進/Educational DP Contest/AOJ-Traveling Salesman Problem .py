# AOJ DPL_2_A: Traveling Salesman Problem
# URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_2_A&lang=ja
# 日付: 2020/12/27

# ---------- 思ったこと / 気づいたこと ----------
# 初めて解くbit DP


# ------------------- 方針 --------------------
# bit DPの根本的なアイデア:
# ある頂点までの道のりにかかわらず，その頂点以降の最適な道のりは等しい
# 残りの頂点の巡り方は，すでに巡った頂点の巡り方とは関係ない

# S: すでに訪れた頂点の集合 (bitで管理)
# Sは2**(n)分用意する必要がある
# 頂点が{0,1,2,3,4}あるとして，そのうち0,1,4に訪れていれば，2進数ならS=10011で，10進数なら19である
# スタート地点の頂点0は必ず訪れてるので，bitの1桁目が1ではないケースは考える必要はないが，面倒なのでそのままにする
# dp[S][v]: 部分集合Sに含まれるすべての頂点を巡り，最後に頂点vに辿り着くまでの最小コスト
# vは必ずSに含まれている必要がある
# 頂点vに向かうすべての頂点kについて
# dp[S][v] = min(dp[S-{v}][k] + dist(k, v)
# つまり，頂点vに矢印が向かっている頂点kを含んでいてかつvだけ含まない部分集合dp[S-{v}][k]から飛んでくることができる。

# 得られたdpの結果は頂点0から全ての頂点を巡って，0以外の別の頂点に至る最短経路なので，最後にこの点から0への距離を足してあげることで
# 本当の経路になる。つまりdp[最後][v]+dist(最後のvから頂点0)がminになるように出力する

# ------------------- 解答 --------------------
#code:python
n, m = map(int, input().split())
G_to = [[] for _ in range(n)] # 各インデックスの頂点に矢印が向かっている[頂点a，重みw]
for _ in range(m):
    a, b, w = map(int, input().split())
    G_to[b].append([a, w])

inf = float('INF')
dp = [[inf]*n for _ in range(2**n)]
dp[1][0] = 0

for S in range(1 << n): # range(2**n)と同じ書き方。Sは0から2**n -1までの整数
    for v in range(n):
        if (S & (1 << v)) == 0: continue # vは必ずSに含まれてる必要がある

        # Sからvを除いた集合:推移式の{S-{v}}の部分
        sub = S ^ (1 << v)
        for k, w in G_to[v]: # 頂点kから頂点v，重さはw
            dp[S][v] = min(dp[S][v], dp[sub][k] + w)

# 最後に到着した頂点vから頂点0までの距離を加味して，最小のコストを出力する
ans = inf
for v, w in G_to[0]:
    ans = min(ans, dp[2**n-1][v] + w)

if ans == inf: print(-1)
else: print(ans)


# ------------------ 入力例 -------------------
4 6
0 1 2
1 2 3
1 3 9
2 0 1
2 3 6
3 2 4


3 3
0 1 1
1 2 1
0 2 1
# ----------------- 解答時間 ------------------
# 3時間くらい

# -------------- 解説 / 感想 / 反省 -------------
# エグい。理解できたつもりだけど，とてもエグい。
# 

# ----------------- カテゴリ ------------------
#AOJ
#解説AC #復習したい
#bitDP
#動的最適化
#TSP
#サラリーマン