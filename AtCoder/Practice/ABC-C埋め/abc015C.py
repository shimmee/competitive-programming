# ABC015C - 高橋くんのバグ探し
# URL: https://atcoder.jp/contests/abc015/tasks/abc015_3
# 日付: 2020/12/17

# ---------- 思ったこと / 気づいたこと ----------
# nによってループの回数が違うから，深さ優先探索の再帰関数で組み合わせのリストを全列挙するやつや！！
# ハローさんに習ったやつ！

# ------------------- 方針 --------------------
#

# 再起で欲しいリストの形は
# [[1,2,1], [1,2,3], ...]みたいなの

# n=0のときは[[]]を出力
# 入力例1を例に取ると，まずn=1のときは[[1], [3], [5], [7]]が欲しい
# n=2のときには [[1,2], [1,4], [1,2], [1,3], [3,2], [3,4], ...] みたいな感じで16のリストが入ってて欲しい
# n=3のときには[[1,2,1], [1,2,3],...] みたいに64のリストが入ってて欲しい

# この数列が全列挙できたら，あとはa1^a2^a3^...を計算して0かどうか確認するだけ

# ------------------- 解答 --------------------
#code:python
import sys
sys.setrecursionlimit(1000000)
n, k = map(int, input().split())
T = [[int(i) for i in input().split()] for _ in range(n)]

# Tのn行目からどんどん追加していく
def rec(i):
    if i == 0:
        return [[]]

    rest_pattern = rec(i-1)
    pattern = []
    # rest_patternの各要素(リスト)にT[i]の要素を1つずつ足して，新しくpatternというリストに加える
    for t in T[i-1]:
        for p in rest_pattern:
            pattern += [p + [t]]
    return pattern

pattern = rec(n)
flag = False # バグ発見のフラッグ
for p in pattern:
    cnt = 0
    for i in p:
        cnt ^= i # 排他的論理和
    if cnt == 0:
        flag = True
if flag: print('Found')
else: print('Nothing')

# ------------------ 入力例 -------------------
3 4
1 3 5 17
2 4 2 3
1 3 2 9

5 3
89 62 15
44 36 17
4 24 24
25 98 99
66 33 57


# ----------------- 解答時間 ------------------
# 36分

# -------------- 解説 / 感想 / 反省 -------------
# https://www.slideshare.net/chokudai/abc015
# 初めてDFSの再帰関数で順列を全列挙できた。ハローさんのおかげ
# nによってループの回数が違うから再起だと気づけた！

# ----------------- カテゴリ ------------------
#AtCoder #abc
#DFS #深さ優先探索
#再帰関数
#復習したい
#排他的論理和
